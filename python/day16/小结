模块的循环导入问题:
    原因:
        模块m1中导入模块m2，模块m2中导入模块m1
    发送问题原因：
        1）m1要使用m2内部名字需要导入m2，反之一样
        2）m1|m2出现循环导入后，导入逻辑在名字产生之前，
        导致使用名字时，名字并未产生
    解决方法:
        方法一:先产生名字，在导入模块（代码执行顺序）
        方式二:先产生函数名字和要使用的变量名字，导入逻辑未产生(延迟导入)
        两个模块都必须解决,你不知道会导哪一个

区分python文件的两种用途:模块/执行文件
    print(__name__)可以看到是作为执行文件(__main__),还是作为模块(模块名)
    if __name__ == '__main__':#如果现在这个文件是执行文件
        src.run()
    else:#如果这个文件是模块
        pass
    作为模块使用时，内部一般不会出现功能的自调用
模块的搜索路径:
     模块搜索路径的优先级
        1. 内存中已经加载过的
        2. 内置模块
        3. sys.path(环境变量) #  第一个值是当前执行文件所在的文件夹
     绝对导入: 以执行文件的sys.path为起始点开始导入,称之为绝对导入
       优点: 执行文件与被导入的模块中都可以使用
       缺点: 所有导入都是以sys.path为起始点,导入麻烦

    相对导入: 参照当前所在文件的文件夹为起始开始查找,称之为相对导入
           符号: .代表当前所在文件的文件加,..代表上一级文件夹,...代表上一级的上一级文件夹
           优点: 导入更加简单
           缺点: 只能在被导入的模块中使用,不能在执行文件中用

    from dir0.dir1 import m1 # 执行文件中只能用绝对导入

    print(__file__)#当前执行文件的路径
    print(os.path.dirname(__file__))#返回当前文件的父文件夹
    print(os.path.dirname(os.path.dirname(__file__)))#返回当前父文件夹的父文件夹
软件开发的目录规范:
ATM
|
----bin
        |
        ----start.py
|
----conf
        |
        ----setting.py
|
----db
        |
        ----db.txt
|
----lib
        |
        ----common.py
|
----log
        |
        ----log.txt
|
----core
        |
        ----src.py
|
----Readme